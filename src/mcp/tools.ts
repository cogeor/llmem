/**
 * MCP Tool Definitions and Implementations
 * 
 * Defines the 5 MCP tools exposed to Antigravity IDE:
 * - get_artifact: Retrieve a saved artifact
 * - list_artifacts: Query artifact index
 * - generate_artifact: Parse file and create artifact
 * - generate_prompt: Build prompt for host LLM
 * - store_llm_result: Store LLM output as artifact
 * 
 * STUB IMPLEMENTATION: Returns placeholder data.
 * See FUTURE MODULE INTEGRATION section in plan/2-mcp.txt for integration guide.
 */

import { z } from 'zod';
import {
    McpResponse,
    validateRequest,
    formatSuccess,
    formatError,
    formatPromptResponse,
    generateCorrelationId,
    logRequest,
    logResponse,
} from './handlers';
import {
    ensureArtifacts,
    saveFolderSummary,
} from '../artifact/service';
import { ArtifactRecord } from '../artifact/types';

// ============================================================================
// Tool Schemas (Zod)
// ============================================================================

export const GetArtifactsSchema = z.object({
    path: z.string().describe('Folder path to analyze'),
    recursive: z.boolean().optional().describe('Whether to search recursively').default(false),
});

export const StoreFolderSummarySchema = z.object({
    path: z.string().describe('Folder path'),
    summary: z.string().describe('Generated summary'),
});

// Type inference
export type GetArtifactsArgs = z.infer<typeof GetArtifactsSchema>;
export type StoreFolderSummaryArgs = z.infer<typeof StoreFolderSummarySchema>;

// ============================================================================
// Tool Handlers
// ============================================================================

/**
 * Get architectural insights for a folder.
 * Returns file signatures and prompts for a summary.
 */
export async function handleGetArtifacts(
    args: unknown
): Promise<McpResponse<never>> {
    const correlationId = generateCorrelationId();
    logRequest(correlationId, 'get_artifacts', args);

    // Validate input
    const validation = validateRequest(GetArtifactsSchema, args);
    if (!validation.success) {
        const response = formatError(validation.error!);
        logResponse(correlationId, response);
        return response;
    }

    const { path, recursive } = validation.data!;

    try {
        const artifacts = await ensureArtifacts(path, recursive);

        // Extract just the signatures/data for the prompt
        // We only want the JSON content we generated
        const contextData = artifacts.map(r => {
            try {
                return JSON.parse(r.content);
            } catch {
                return { path: r.metadata.sourcePath, error: "Could not parse artifact content" };
            }
        });

        const prompt = `You are an Architectural Codebase Assistant.
Context: I have analyzed the folder "${path}".

Here are the signatures of the files in this folder:
${JSON.stringify(contextData, null, 2)}

Task:
Summarize the functionality of this folder/module. 
1. What is its primary responsibility?
2. What are its main external inputs and outputs (based on signatures)?
3. How do the files interact?

Format: Markdown`;

        const response = formatPromptResponse(
            prompt,
            'store_folder_summary',
            { path }
        );
        logResponse(correlationId, response);
        return response;

    } catch (error) {
        const response = formatError(error instanceof Error ? error.message : String(error));
        logResponse(correlationId, response);
        return response;
    }
}

/**
 * Store the summary generated by the Host LLM.
 */
export async function handleStoreFolderSummary(
    args: unknown
): Promise<McpResponse<unknown>> {
    const correlationId = generateCorrelationId();
    logRequest(correlationId, 'store_folder_summary', args);

    // Validate input
    const validation = validateRequest(StoreFolderSummarySchema, args);
    if (!validation.success) {
        const response = formatError(validation.error!);
        logResponse(correlationId, response);
        return response;
    }

    const { path, summary } = validation.data!;

    try {
        const metadata = await saveFolderSummary(path, summary);
        const response = formatSuccess({
            message: "Folder summary saved successfully",
            metadata
        });
        logResponse(correlationId, response);
        return response;
    } catch (error) {
        const response = formatError(error instanceof Error ? error.message : String(error));
        logResponse(correlationId, response);
        return response;
    }
}

// ============================================================================
// Tool Registry
// ============================================================================

export interface ToolDefinition {
    name: string;
    description: string;
    schema: z.ZodSchema;
    handler: (args: unknown) => Promise<McpResponse<unknown>>;
}

export const TOOLS: ToolDefinition[] = [
    {
        name: 'get_artifacts',
        description: 'Get architectural insights for a folder. Returns file signatures and triggers summary generation.',
        schema: GetArtifactsSchema,
        handler: handleGetArtifacts,
    },
    {
        name: 'store_folder_summary',
        description: 'Store the summary generated by the Host LLM for a folder.',
        schema: StoreFolderSummarySchema,
        handler: handleStoreFolderSummary,
    },
];
