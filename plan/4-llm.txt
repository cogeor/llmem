# Gemini Client Implementation Plan
# Component: src/llm/

================================================================================
## PURPOSE
================================================================================
LLM API communication. Handles Gemini API calls, prompt construction
from file content and code structure, and parsing LLM responses into
structured artifacts.

================================================================================
## FILES & RESPONSIBILITIES
================================================================================

### client.ts
- Gemini API wrapper
- Authentication (API key from config)
- Request/response handling
- Retry logic with exponential backoff
- Rate limiting

### prompt-builder.ts
- Construct prompts from:
  - System instructions (artifact generation context)
  - File content (source code)
  - Code structure (from parser module)
  - User intent/prompt
- Token budget management
- Template selection based on artifact type

### response-parser.ts
- Parse Gemini responses
- Extract structured artifacts from LLM output
- Handle single vs multi-artifact responses
- Validate output format

================================================================================
## MODULE INTERACTIONS
================================================================================

INTERNAL (within llm/):
                    ┌─────────────────┐
                    │   client.ts     │
                    │                 │
                    │ - callGemini()  │
                    │ - retry logic   │
                    └────────┬────────┘
                             │
         ┌───────────────────┼───────────────────┐
         │                   │                   │
         ▼                   │                   ▼
┌─────────────────┐          │          ┌─────────────────┐
│ prompt-builder  │          │          │ response-parser │
│                 │──────────┘          │                 │
│ - buildPrompt() │    uses both        │ - parse()       │
│ - templates     │                     │ - validate()    │
└────────┬────────┘                     └─────────────────┘
         │
         │ receives code structure
         ▼
┌─────────────────┐
│  parser/outline │
│  (external)     │
└─────────────────┘

EXTERNAL DEPENDENCIES:
- client.ts → Receives config from extension/config.ts
- prompt-builder.ts → Calls parser/outline.ts for code structure
- client.ts → Called by mcp/tools.ts for artifact generation

================================================================================
## INTERFACES
================================================================================

```typescript
// client.ts exports
interface GeminiOptions {
  model?: string;
  temperature?: number;
  maxTokens?: number;
}

async function callGemini(prompt: string, options?: GeminiOptions): Promise<string>;

// prompt-builder.ts exports
interface PromptContext {
  files: Array<{ path: string; content: string }>;
  codeOutline?: CodeOutline;  // from parser module
  userPrompt: string;
  artifactTypes: string[];
}

function buildPrompt(context: PromptContext): string;

// response-parser.ts exports
interface ParsedArtifact {
  type: string;
  content: string;
  metadata?: Record<string, unknown>;
}

function parseResponse(response: string, expectedTypes: string[]): ParsedArtifact[];
```

================================================================================
## PROMPT TEMPLATES
================================================================================

System instruction template (in prompt-builder.ts):
```
You are an AI assistant generating code artifacts.

PROJECT CONTEXT:
{codeOutline - list of files, classes, functions}

SOURCE FILES:
{file contents with path headers}

TASK:
Generate the following artifacts: {artifactTypes}

USER REQUEST:
{userPrompt}

OUTPUT FORMAT:
Return artifacts as markdown sections with headers:
## [artifact-type]
{content}
```

================================================================================
## IMPLEMENTATION ORDER
================================================================================

1. response-parser.ts
   - Parse logic independent of API
   - Can test with mock responses

2. prompt-builder.ts
   - Template construction
   - Depends on parser types

3. client.ts
   - API integration
   - Uses prompt-builder and response-parser

================================================================================
## DEPENDENCIES
================================================================================

External packages:
- @google/generative-ai (Gemini SDK)
  OR
- fetch (REST API direct)

Internal dependencies:
- Depends on: extension/config, parser/outline
- Depended on by: mcp/tools.ts

================================================================================
## TESTING
================================================================================

### Unit Tests (llm/)

response-parser.ts:
- parseResponse() extracts single artifact
- parseResponse() extracts multiple artifacts
- parseResponse() handles malformed response gracefully
- validate() rejects missing required fields

prompt-builder.ts:
- buildPrompt() includes system instructions
- buildPrompt() includes file content
- buildPrompt() includes code outline when provided
- buildPrompt() respects token budget
- Template selection based on artifact type

client.ts:
- callGemini() sends correct API request
- callGemini() retries on transient errors
- callGemini() respects rate limits
- callGemini() times out appropriately

### Integration Tests (llm/ ↔ other modules)

LLM ↔ Parser:
- Test: buildPrompt() correctly uses CodeOutline from parser
- Test: Missing outline falls back gracefully
- Test: Large outlines are truncated appropriately

LLM ↔ Config:
- Test: API key loaded from config
- Test: Model setting respected
- Test: Temperature setting applied

LLM ↔ MCP:
- Test: MCP generate_artifact receives parsed artifacts
- Test: LLM errors surface correctly in MCP response

### Integration Tests (with mock API)

End-to-End with Mock Gemini:
- Test: Full prompt → response → parsed artifacts flow
- Test: Multi-artifact response parsed correctly
- Test: Retry logic with intermittent failures

### Module Compatibility Tests

API Response Variations:
- Test: Handle Gemini API format changes
- Test: Handle unexpected response structure
- Test: Handle streaming vs non-streaming responses
