# Part 4: Text Processing Implementation Plan
# Component: src/parser/

================================================================================
## PURPOSE
================================================================================
Robust code structure extraction using Tree-sitter and S-expression queries.
Parses source files into AST, runs queries to extract imports, exports, entities,
and callsites, and stores as structured JSON in `.artifact` files.

DESIGN GOAL: For each source file, generate a corresponding .artifact file containing
rich structural data (entities + callsites) to enable downstream graph construction.

Example:
  src/extension/config.ts â†’ .artifacts/src/extension/config.ts.artifact

================================================================================
## FILES & RESPONSIBILITIES
================================================================================

### parser.ts
- Tree-sitter initialization
- Language detection from file extension
- Load appropriate language grammar
- Parse file content into AST

### extractor.ts
- Load S-expression queries (imports, exports, entities, callsites)
- Iterate captures from `tree.query`
- Construct `FileArtifact` JSON structure
- Handle scope attribution for callsites (ensure calls belong to correct callable)

### queries/*.scm (New)
- `imports.scm`: Extract ES imports
- `exports.scm`: Extract named/default/star exports
- `entities.scm`: Extract functions, classes, methods, arrows
- `callsites.scm`: Extract call expressions and new expressions

### types.ts
- `FileArtifact`, `Entity`, `ImportSpec`, `CallSite` interfaces (see Data Model)

================================================================================
## DATA MODEL (Artifact JSON Structure)
================================================================================

```typescript
type Loc = {
  startByte: number; endByte: number;
  startLine: number; endLine: number;
  startColumn: number; endColumn: number;
};

type FileArtifact = {
  schemaVersion: "ts-graph-v1";
  file: { id: string; path: string; language: string };
  imports: ImportSpec[];
  exports: ExportSpec[];
  entities: Entity[];
};

type ImportSpec = {
  kind: "es";
  source: string;             // raw module specifier
  resolvedPath: string | null;
  specifiers: { name: string; alias?: string }[];
  loc: Loc;
};

type ExportSpec = {
  type: "named" | "default" | "reexport" | "all";
  name: string;      // exported name
  localName?: string; // local entity name if different
  source?: string;   // for re-exports
  loc: Loc;
};

type EntityKind = "class" | "function" | "method" | "arrow" | "const";

type Entity = {
  id: string; // generated stable ID (e.g. file#name@byte)
  kind: EntityKind;
  name: string;
  isExported: boolean;
  loc: Loc;
  signature?: string; // full signature text
  calls?: CallSite[]; // outgoing calls
};

type CallSite = {
  callSiteId: string;
  kind: "function" | "method" | "new";
  calleeName: string; // best effort name extraction
  loc: Loc;
};
```

================================================================================
## TREE-SITTER QUERIES (Reference)
================================================================================

### imports.scm
```scm
(import_statement
  (import_clause
    (identifier) @import.default)?
  (import_clause
    (named_imports
      (import_specifier
        name: (identifier) @import.imported
        alias: (identifier)? @import.local)?))?
  (string) @import.source) @import.stmt
```

### exports.scm
```scm
; Named export
(export_statement
  (function_declaration name: (identifier) @export.name)) @export.stmt

; Re-export
(export_statement
  (export_clause
    (export_specifier name: (identifier) @reexport.name))
  source: (string) @reexport.source) @reexport.stmt
```

### entities.scm
```scm
(function_declaration name: (identifier) @entity.name) @entity.function
(class_declaration name: (identifier) @entity.name) @entity.class
(method_definition name: (property_identifier) @entity.name) @entity.method
(lexical_declaration
  (variable_declarator
    name: (identifier) @entity.name
    value: (arrow_function))) @entity.arrow
```

### callsites.scm
```scm
(call_expression
  function: (_) @call.callee) @call.expr
(new_expression
  constructor: (_) @call.callee) @call.new
```

================================================================================
## IMPLEMENTATION STRATEGY
================================================================================

1.  **Query Files**: Create `.scm` files in `src/parser/queries/`.
2.  **Extractor Class**:
    -   Initialize with query contents.
    -   Method `extract(tree, language)`:
        -   Run `imports` query -> build `ImportSpec[]`.
        -   Run `exports` query -> build `ExportSpec[]`.
        -   Run `entities` query -> build `Entity[]` (flat list).
        -   Run `callsites` query OR traverse entities to find calls within scopes (Scope-Sensitive Traversal recommended for correct attribution).
3.  **Service Integration**:
    -   Update `ensureArtifacts` in `src/artifact/service.ts`.
    -   Serialize extraction result to JSON string.
    -   Write to `.artifact`.

================================================================================
## VERIFICATION
================================================================================

-   **Unit Tests**: Test extractor against fixture TS files (imports, exports, nested arrows).
-   **Artifact Check**: Verify generated JSON contains expected structure.
-   **Summary Check**: Ensure top-level folder logic works (via `analyze_codebase` integration).
